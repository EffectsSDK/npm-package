import { EffectProcessor } from "./effect_processor";
import { Component } from "./components/component";
import { OverlayScreen, OverlayScreenOptions } from "./components/overlay-screen/overlayScreen";
import { WaterMark, WatermarkOptions } from "./components/waterMark/waterMark";
import { StikerOptions, Stikers } from "./components/stickers/stickers";
import { LtOptions } from "./components/lower-third/lowerThird";
import { LtLeftTextbox } from "./components/lower-third/collection/leftTextbox";
import { LtHorizontalMirror } from "./components/lower-third/collection/horizontalMirror";
import { LtSlideBold } from "./components/lower-third/collection/slideBold";
import { LtDoubleSlideRect } from "./components/lower-third/collection/doubleSlideRect";
import { LtTwoSlideRects } from "./components/lower-third/collection/twoSideRects/twoSlideRects";
type ResizeSettings = {
    width: number;
    height: number;
};
export declare class tsvb {
    onReady?: () => void;
    private streamProcessor;
    private effectProcessor;
    private custom_inference;
    private onnx_inference;
    private virtualBackgroundEffect;
    private smartZoomEffect;
    private colorCorrectorEffect;
    components: {
        [key: string]: Component;
    };
    customer_id: string;
    static WIDTH: number;
    static HEIGHT: number;
    static OUTPUT_WIDTH: number;
    static OUTPUT_HEIGHT: number;
    static DEBUG_MODE: boolean;
    static enableDebugMode(): void;
    static disableDebugMode(): void;
    static log(message: any): void;
    static authRequestFunction?: (url: string, payload: Object) => Promise<string>;
    onAuthRequest(func: (url: string, payload: Object) => Promise<string>): void;
    constructor(customer_id: string, inference?: any);
    config(config: any): void;
    private init;
    getCustomerId(): string;
    useStream(stream: MediaStream, resize?: ResizeSettings): void;
    setSegmentationPreset(preset: string): Promise<boolean>;
    getSegmentationPreset(): string;
    setBackgroundColor(color: number): void;
    getStream(): MediaStream | null;
    toCanvas(canvas: HTMLCanvasElement): void;
    setFpsLimit(limit: number): boolean;
    showFps(): boolean;
    hideFps(): boolean;
    enableBeautification(): boolean;
    disableBeautification(): boolean;
    setBoundaryMode(mode: string): boolean;
    setBackgroundFitMode(mode: string): boolean;
    setBoundaryLevel(level: number): boolean;
    setBeautificationLevel(level: number): boolean;
    setBlur(power: number): boolean;
    clearBlur(): boolean;
    setBackground(url: string | MediaStream | MediaStreamTrack | HTMLVideoElement): boolean;
    clearBackground(): boolean;
    enableFrameSkipping(): boolean;
    disableFrameSkipping(): boolean;
    setLayout(mode: string): boolean;
    setFaceArea(value: number): boolean;
    setFaceDetectorAccuracy(value: number): boolean;
    setSmartZoomSmoothing(steps: number): boolean;
    setSmartZoomSensitivity(value: number): boolean;
    setSmartZoomPerod(value: number): boolean;
    switchDrawFaceSquare(isOn: boolean): boolean;
    switchDrawPreFaceSquare(isOn: boolean): boolean;
    enableSmartZoom(): boolean;
    disableSmartZoom(): boolean;
    enableColorCorrector(): boolean;
    disableColorCorrector(): boolean;
    setFilterPart(value: number): boolean;
    setColorCorrectorPeriod(value: number): boolean;
    setColorCorrectorPower(value: number): boolean;
    clear(): boolean;
    run(): boolean;
    stop(): boolean;
    setCustomLayout(persent: {
        xOffset?: number;
        yOffset?: number;
        size?: number;
    }): boolean;
    enablePipelineSkipping(): void;
    disablePipelineSkipping(): void;
    getEffectProcessor(): EffectProcessor;
    createComponent<K extends Keys>(arg: K extends OptionsKeys ? ComponentArguments<K> : Omit<ComponentArguments<K>, "options">): ClassType<K>;
    addComponent<K extends Keys>(c: ClassType<K>, id: string): void;
    getComponentConstructor<K extends Keys>(key: K): {
        overlay_screen: typeof OverlayScreen;
        watermark: typeof WaterMark;
        lowerthird_1: typeof LtLeftTextbox;
        lowerthird_2: typeof LtHorizontalMirror;
        lowerthird_3: typeof LtSlideBold;
        lowerthird_4: typeof LtDoubleSlideRect;
        lowerthird_5: typeof LtTwoSlideRects;
        stickers: typeof Stikers;
    }[K];
    setOutputResolution(size: Partial<ResizeSettings>): void;
}
declare const componentsMap: {
    overlay_screen: typeof OverlayScreen;
    watermark: typeof WaterMark;
    lowerthird_1: typeof LtLeftTextbox;
    lowerthird_2: typeof LtHorizontalMirror;
    lowerthird_3: typeof LtSlideBold;
    lowerthird_4: typeof LtDoubleSlideRect;
    lowerthird_5: typeof LtTwoSlideRects;
    stickers: typeof Stikers;
};
interface OptionsMap {
    overlay_screen: OverlayScreenOptions;
    watermark: WatermarkOptions;
    lowerthird_1: LtOptions;
    lowerthird_2: LtOptions;
    lowerthird_3: LtOptions;
    lowerthird_4: LtOptions;
    lowerthird_5: LtOptions;
    stickers: StikerOptions;
}
type ComponentsMap = typeof componentsMap;
type Keys = keyof ComponentsMap;
type OptionsKeys = keyof OptionsMap;
type Tuples<T> = T extends Keys ? [T, InstanceType<ComponentsMap[T]>] : never;
type SingleKey<K> = [K] extends (K extends Keys ? [K] : never) ? K : never;
type ClassType<A extends Keys> = Extract<Tuples<Keys>, [A, any]>[1];
interface ComponentArguments<K extends Keys> {
    component: SingleKey<K>;
    options: K extends OptionsKeys ? OptionsMap[K] : never;
}
export {};
